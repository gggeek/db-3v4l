#!/usr/bin/env bash

# Shortcuts to manage the whole set of containers

# @todo allow end user to enter pwd for root db accounts on build. If not interactive, generate a random one
# @todo check for ports conflicts before starting the web container
# @todo if there's no docker-compose onboard but there is curl or wget, download and install docker-compose
# @todo add a command to remove the built containers and their anon volumes ? eg. `docker-compose rm -s -v`

# consts
APP_DEFAULT_CONFIG_FILE=containers.env
DOCKER_DEFAULT_CONFIG_FILE=.env
BOOTSTRAP_OK_FILE=/var/run/bootstrap_ok
WORKER_SERVICE=worker
# vars
APP_LOCAL_CONFIG_FILE=
AS_ROOT=false
BOOTSTRAP_TIMEOUT=300
CLEANUP_UNUSED_IMAGES=false
DOCKER_NO_CACHE=
PARALLEL_BUILD=
PULL_IMAGES=false
REBUILD=false
RECREATE=false
SETUP_APP_ON_BUILD=true
SILENT=false
VERBOSITY=
WORKER_CONTAINER=
WORKER_USER=

help() {
    printf "Usage: dbstack [OPTIONS] COMMAND [OPTARG]

Manages the Db3v4l Docker Stack

Commands:
    build               build or rebuild the complete set of containers and set up the app. Leaves the stack running
    cleanup CATEGORY    remove tmeporary data/logs/caches/etc... CATEGORY can be any of:
                        - databases       NB: this removes all your data! Better done when containers are stopped
                        - docker-images   removes only unused images. Can be quite beneficial to free up space
                        - docker-logs     NB: for this to work, you'll need to run this script as root
                        - logs            removes log files from the databases, webservers, symfony
                        - shared-data     removes every file in the ./shared folder
    images              list container images
    kill                kill containers
    logs                view output from containers
    monitor             starts an interactive console for monitoring containers, images, volumes
    pause               pause the containers
    ps                  show the status of running containers
    setup               set up the app without rebuilding the containers first
    run                 execute a single command in the worker container
    shell               start a shell in the worker container as the application user
    services            list docker-compose services
    start               start the complete set of containers
    stop                stop the complete set of containers
    top                 display the running container processes
    unpause             unpause the containers

Options:
    -c              clean up docker images which have become useless - when running 'build'
    -h              print help
    -n              do not set up the app - when running 'build'
    -p              build containers in parallel - when running 'build'
    -s              force app set up (via resetting containers to clean-build status besides updating them if needed) - when running 'build'
    -r              force containers to rebuild from scratch (this forces a full app set up as well) - when running 'build'
                    log in as root instead of the app user account - when running 'shell' and 'run'
    -u              update containers by pulling the base images - when running 'build'
    -v              verbose mode
    -w SECONDS      wait timeout for completion of app and container set up - when running 'build' and 'start'. Defaults to ${BOOTSTRAP_TIMEOUT}
    -z              avoid using docker cache - when running 'build -r'
"
}

check_requirements() {
    which docker >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        printf "\n\e[31mPlease install docker & add it to \$PATH\e[0m\n\n" >&2
        exit 1
    fi

    which docker-compose >/dev/null 2>&1
    if [ $? -ne 0 ]; then
        printf "\n\e[31mPlease install docker-compose & add it to \$PATH\e[0m\n\n" >&2
        exit 1
    fi
}

load_default_config() {
    COMPOSEPROJECT=$(grep -F COMPOSE_PROJECT_NAME ${DOCKER_DEFAULT_CONFIG_FILE} | sed 's/COMPOSE_PROJECT_NAME=//')
    if [ -z "${COMPOSEPROJECT}" ]; then
        printf "\n\e[31mCan not find the name of the composer project name in ${DOCKER_DEFAULT_CONFIG_FILE}\e[0m\n\n" >&2
        exit 1
    fi
    WORKER_CONTAINER="${COMPOSEPROJECT}_${WORKER_SERVICE}"
    WORKER_USER=$(grep -F CONTAINER_USER ${DOCKER_DEFAULT_CONFIG_FILE} | sed 's/CONTAINER_USER=//')
    if [ -z "${WORKER_USER}" ]; then
        printf "\n\e[31mCan not find the name of the container user account in ${DOCKER_DEFAULT_CONFIG_FILE}\e[0m\n\n" >&2
        exit 1
    fi
    APP_LOCAL_CONFIG_FILE=$(grep -F COMPOSE_CONTAINERS_ENV_OVERRIDE_FILE ${DOCKER_DEFAULT_CONFIG_FILE} | sed 's/COMPOSE_CONTAINERS_ENV_OVERRIDE_FILE=//')
    if [ -z "${APP_LOCAL_CONFIG_FILE}" ]; then
        printf "\n\e[31mCan not find the name of the container local config file in ${DOCKER_DEFAULT_CONFIG_FILE}\e[0m\n\n" >&2
        exit 1
    fi
}

setup_local_config() {
    echo "[`date`] Setting up the configuration file..."

    CURRENT_USER_UID=$(id -u)
    CURRENT_USER_GID=$(id -g)

    CONTAINER_USER_UID=$(grep -F CONTAINER_USER_UID ${APP_DEFAULT_CONFIG_FILE} | sed 's/CONTAINER_USER_UID=//')
    CONTAINER_USER_GID=$(grep -F CONTAINER_USER_GID ${APP_DEFAULT_CONFIG_FILE} | sed 's/CONTAINER_USER_GID=//')

    touch ${APP_LOCAL_CONFIG_FILE}

    # @todo in case the file already has these vars, replace them instead of appending!
    if [ "${CONTAINER_USER_UID}" != "${CURRENT_USER_UID}" ]; then
        echo "CONTAINER_USER_UID=${CURRENT_USER_UID}" >> ${APP_LOCAL_CONFIG_FILE}
    fi
    if [ "${CONTAINER_USER_GID}" != "${CURRENT_USER_GID}" ]; then
        echo "CONTAINER_USER_GID=${CURRENT_USER_GID}" >> ${APP_LOCAL_CONFIG_FILE}
    fi

    # @todo allow setting up: custom db root account pwd, sf env, etc...
}

build() {
    if [ ${CLEANUP_UNUSED_IMAGES} = 'true' ]; then
        # for good measure, do a bit of hdd disk cleanup ;-)
        echo "[`date`] Removing unused Docker images from disk..."
        docker rmi $(docker images | grep "<none>" | awk "{print \$3}")
    fi

    echo "[`date`] Building and Starting all Containers..."

    docker-compose ${VERBOSITY} stop
    if [ ${REBUILD} = 'true' ]; then
        docker-compose ${VERBOSITY} rm -f
    fi

    if [ ${PULL_IMAGES} = 'true' ]; then
        echo "[`date`] Pulling base Docker images..."
        IMAGES=$(find . -name Dockerfile | xargs fgrep -h 'FROM' | sort -u | sed 's/FROM //g')
        for IMAGE in $IMAGES; do
            docker pull $IMAGE
        done
    fi

    docker-compose ${VERBOSITY} build ${PARALLEL_BUILD} ${DOCKER_NO_CACHE}

    if [ ${SETUP_APP_ON_BUILD} = 'false' ]; then
        export COMPOSE_SETUP_APP_ON_BOOT=false
    fi

    if [ ${RECREATE} = 'true' ]; then
        docker-compose ${VERBOSITY} up -d --force-recreate
    else
        docker-compose ${VERBOSITY} up -d
    fi

    wait_for_bootstrap all
    RETCODE=$?

    if [ ${CLEANUP_UNUSED_IMAGES} = 'true' ]; then
        echo "[`date`] Removing unused Docker images from disk, again..."
        docker rmi $(docker images | grep "<none>" | awk "{print \$3}")
    fi

    echo "[`date`] Build finished"

    exit ${RETCODE}
}

setup_app() {
    echo "[`date`] Starting the Worker container..."

    # avoid automatic app setup being triggered here
    export COMPOSE_SETUP_APP_ON_BOOT=false

    docker-compose ${VERBOSITY} up -d ${WORKER_SERVICE}

    wait_for_bootstrap worker
    RETCODE=$?
    if [ ${RETCODE} -ne 0 ]; then
        exit ${RETCODE}
    fi

    echo "[`date`] Setting up the app (from inside the Worker container)..."
    docker exec ${WORKER_CONTAINER} su - ${WORKER_USER} -c "cd /home/${WORKER_USER}/app && composer install"
    echo "[`date`] Setup finished"
}

# Wait until containers have fully booted
wait_for_bootstrap() {

    if [ ${BOOTSTRAP_TIMEOUT} -le 0 ]; then
        return 0
    fi

    case "${1}" in
        admin)
            BOOTSTRAP_CONTAINERS=adminer
        ;;
        all)
            # q: check all services or only the running ones?
            #BOOTSTRAP_CONTAINERS=$(docker-compose config --services)
            BOOTSTRAP_CONTAINERS=$(docker-compose ps --services | tr '\n' ' ')
        ;;
        app)
            BOOTSTRAP_CONTAINERS='worker web adminer'
        ;;
        #web)
        #    BOOTSTRAP_CONTAINERS=web
        #;;
        #worker)
        #    BOOTSTRAP_CONTAINERS=worker
        #;;
        *)
            #printf "\n\e[31mERROR: unknown booting container: ${1}\e[0m\n\n" >&2
            #help
            #exit 1
            # @todo add check that this service is actually defined
            BOOTSTRAP_CONTAINERS=${1}
        ;;
    esac

    echo "[`date`] Waiting for containers bootstrap to finish..."

     i=0
     while [ $i -le "${BOOTSTRAP_TIMEOUT}" ]; do
        sleep 1
        BOOTSTRAP_OK=''
        for BS_CONTAINER in ${BOOTSTRAP_CONTAINERS}; do
            printf "Waiting for ${BS_CONTAINER} ... "
            # @todo speed this up... maybe go back to generating and checking files mounted on the host?
            docker-compose exec ${BS_CONTAINER} cat ${BOOTSTRAP_OK_FILE} >/dev/null 2>/dev/null
            RETCODE=$?
            if [ ${RETCODE} -eq 0 ]; then
                printf "\e[32mdone\e[0m\n"
                BOOTSTRAP_OK="${BOOTSTRAP_OK} ${BS_CONTAINER}"
            else
                echo;
            fi
        done
        if [ -n "${BOOTSTRAP_OK}" ]; then
            for BS_CONTAINER in ${BOOTSTRAP_OK}; do
                BOOTSTRAP_CONTAINERS=${BOOTSTRAP_CONTAINERS//${BS_CONTAINER}/}
            done
            if [ -z  "${BOOTSTRAP_CONTAINERS// /}" ]; then
                break
            fi
        fi
        i=$(( i + 1 ))
    done
    if [ $i -gt 0 ]; then echo; fi

    if [ -n "${BOOTSTRAP_CONTAINERS// /}" ]; then
        printf "\n\e[31mBootstrap process did not finish within ${BOOTSTRAP_TIMEOUT} seconds\e[0m\n\n" >&2
        return 1
    fi

    return 0
}

cleanup() {
    case "${1}" in
        databases)
            if [ ${SILENT} != true ]; then
                echo "Do you really want to delete all database data?"
                select yn in "Yes" "No"; do
                    case $yn in
                        Yes ) break ;;
                        No ) exit 1 ;;
                    esac
                done
            fi

            find ./data/ -type f ! -name .gitkeep -delete
            # leftover sockets happen...
            find ./data/ -type s -delete
            find ./data/ -type d -empty -delete
        ;;
        docker-images)
            docker rmi $(docker images | grep "<none>" | awk "{print \$3}")
        ;;
        docker-logs)
            for CONTAINER in $(docker-compose ps -q)
            do
                LOGFILE=$(docker inspect --format='{{.LogPath}}' ${CONTAINER})
                if [ -n "${LOGFILE}" ]; then
                    echo "" > ${LOGFILE}
                fi
            done
        ;;
        logs)
            find ./logs/ -type f ! -name .gitkeep -delete
            find ../app/var/log/ -type f ! -name .gitkeep -delete
        ;;
        shared-data)
            if [ ${SILENT} != true ]; then
                echo "Do you really want to delete all data in the 'shared' folder?"
                select yn in "Yes" "No"; do
                    case $yn in
                        Yes ) break ;;
                        No ) exit 1 ;;
                    esac
                done
            fi

            find ../shared/ -type f ! -name .gitkeep -delete
        ;;
        symfony-cache)
            find ../app/var/cache/ -type f ! -name .gitkeep -delete
        ;;
        *)
            printf "\n\e[31mERROR: unknown cleanup target: ${1}\e[0m\n\n" >&2
            help
            exit 1
        ;;
    esac
}

# @todo move to a function
while getopts ":chnprsuvw:z" opt
do
    case $opt in
        c)
            CLEANUP_UNUSED_IMAGES=true
        ;;
        h)
            help
            exit 0
        ;;
        n)
            SETUP_APP_ON_BUILD=false
        ;;
        p)
            PARALLEL_BUILD=--parallel
        ;;
        r)
            AS_ROOT=true
            REBUILD=true
        ;;
        s)
            RECREATE=true
        ;;
        u)
            PULL_IMAGES=true
        ;;
        v)
            VERBOSITY=--verbose
        ;;
        w)
            BOOTSTRAP_TIMEOUT=${OPTARG}
        ;;
        z)
            DOCKER_NO_CACHE=--no-cache
        ;;
        \?)
            printf "\n\e[31mERROR: unknown option -${OPTARG}\e[0m\n\n" >&2
            help
            exit 1
        ;;
    esac
done
shift $((OPTIND-1))

COMMAND=$1

check_requirements

cd $(dirname -- ${BASH_SOURCE[0]})/../docker

load_default_config

if [ ! -f ${APP_LOCAL_CONFIG_FILE} ]; then
    setup_local_config
fi

case "${COMMAND}" in
    build)
        build
    ;;

    cleanup)
        cleanup "${2}"
    ;;

    config)
        docker-compose ${VERBOSITY} config ${2}
    ;;

    dbconsole)
        # @deprecated - left in for courtesy
        shift
        # scary line ? found it at https://stackoverflow.com/questions/12343227/escaping-bash-function-arguments-for-use-by-su-c
        docker exec -ti ${WORKER_CONTAINER} su - ${WORKER_USER} -c '"$0" "$@"' -- "/usr/bin/php" "app/bin/dbconsole" "$@"
    ;;

    images)
        docker-compose ${VERBOSITY} images ${2}
    ;;

    kill)
        docker-compose ${VERBOSITY} kill ${2}
    ;;

    logs)
        docker-compose ${VERBOSITY} logs ${2}
    ;;

    monitor)
        docker exec -ti db3v4l_lazydocker lazydocker
    ;;

    ps)
        docker-compose ${VERBOSITY} ps ${2}
    ;;

    pause)
        docker-compose ${VERBOSITY} pause ${2}
    ;;

    run)
        shift
        if [ ${AS_ROOT} = true ]; then
            docker exec -ti ${WORKER_CONTAINER} "$@"
        else
            # @todo should we try to start from the 'app' dir ?
            # q: which one is better? test with a command with spaces in options values, and with a composite command such as cd here && do that
            docker exec -ti ${WORKER_CONTAINER} sudo -iu ${WORKER_USER} -- "$@"
            #docker exec -ti ${WORKER_CONTAINER} su - ${WORKER_USER} -c '"$0" "$@"' -- "$@"
        fi
    ;;

    setup)
        setup_app
    ;;

    shell)
        if [ ${AS_ROOT} = true ]; then
            docker exec -ti ${WORKER_CONTAINER} bash
        else
            docker exec -ti ${WORKER_CONTAINER} sudo -iu ${WORKER_USER}
            #docker exec -ti ${WORKER_CONTAINER} su - ${WORKER_USER}
        fi
    ;;

    start)
        docker-compose ${VERBOSITY} up -d ${2}
        if [ -z "${2}" ]; then
            wait_for_bootstrap all
            exit $?
        else
            wait_for_bootstrap ${2}
            exit $?
        fi
    ;;

    services)
        docker-compose config --services | sort
    ;;

    stop)
        docker-compose ${VERBOSITY} stop ${2}
    ;;

    top)
        docker-compose ${VERBOSITY} top ${2}
    ;;

    unpause)
        docker-compose ${VERBOSITY} unpause ${2}
    ;;

    # achieved by running `build -u`... could be expanded to also do a git pull?
    #update)
    #;;

    *)
        printf "\n\e[31mERROR: unknown command '${COMMAND}'\e[0m\n\n" >&2
        help
        exit 1
    ;;
esac
